# -*- coding: utf-8 -*-
"""Penerapan_Data_Science.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-UeC4yzhyE8YFw_dt3I2AxR03QGt3FP5

# Proyek Akhir: Menyelesaikan Permasalahan Perusahaan Edutech

- Nama:Rahayu Nur Rahmawati
- Email: a229xbm@devacademy.id
- Id Dicoding:A229XBM406

## Persiapan

### Menyiapkan library yang dibutuhkan
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.metrics import classification_report, confusion_matrix, accuracy_score, roc_auc_score, roc_curve
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
from sklearn.linear_model import LogisticRegression
import xgboost as xgb
from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from scipy.stats import skew
from google.colab import drive

"""### Menyiapkan data yang akan digunakan"""

# Mount Google Drive
drive.mount('/content/drive')

# Tentukan path file dataset Anda di Google Drive
path_file = '/content/drive/MyDrive/LASKAR AI/SUBMISSION/employee_data.csv'

# Baca dataset menggunakan pandas
df = pd.read_csv(path_file)
df.head()

"""## Data Understanding

### Kolom (fitur) dalam dataset
"""

df.shape

df.columns.tolist()

"""Data ini berisi detail, metrik terkait pekerjaan, dan flag attrition.

*   EmployeeId - Identifikasi Karyawan
*   Attrition - Apakah karyawan mengalami attrition? (0=tidak, 1=ya)
*   Age - Usia karyawan
*   BusinessTravel - Komitmen perjalanan untuk pekerjaan
*   DailyRate - Gaji harian
*   Department - Departemen Karyawan
*   DistanceFromHome - Jarak dari rumah ke tempat kerja (dalam km)
*   Education - 1-Di Bawah Tingkat Sarjana, 2-Setingkat Perguruan Tinggi, 3-Sarjana, 4-Magister, 5-Doktor
*   EducationField - Bidang Pendidikan
*   EnvironmentSatisfaction - 1-Rendah, 2-Sedang, 3-Tinggi, 4-Sangat Tinggi
*   Gender - Jenis kelamin karyawan
*   HourlyRate - Gaji per jam
*   JobInvolvement - 1-Rendah, 2-Sedang, 3-Tinggi, 4-Sangat Tinggi
*   JobLevel - Tingkatan pekerjaan (1 sampai 5)
*   JobRole - Peran Pekerjaan
*   JobSatisfaction - 1-Rendah, 2-Sedang, 3-Tinggi, 4-Sangat Tinggi
*   MaritalStatus - Status Pernikahan
*   MonthlyIncome - Gaji bulanan
*   MonthlyRate - Tarif bulanan
*   NumCompaniesWorked - Jumlah perusahaan tempat bekerja
*   Over18 - Lebih dari 18 tahun?
*   OverTime - Lembur?
*   PercentSalaryHike - Persentase kenaikan gaji tahun lalu
*   PerformanceRating - 1-Rendah, 2-Baik, 3-Sangat Baik, 4-Luar Biasa
*   RelationshipSatisfaction - 1-Rendah, 2-Sedang, 3-Tinggi, 4-Sangat Tinggi
*   StandardHours - Jam Kerja Standar
*   StockOptionLevel - Tingkat Opsi Saham
*   TotalWorkingYears - Total tahun bekerja
*   TrainingTimesLastYear - Jumlah pelatihan yang diikuti tahun lalu
*   WorkLifeBalance - 1-Rendah, 2-Baik, 3-Sangat Baik, 4-Luar Biasa
*   YearsAtCompany - Tahun bekerja di perusahaan ini
*   YearsInCurrentRole - Tahun dalam peran saat ini
*   YearsSinceLastPromotion - Tahun sejak promosi terakhir
*   YearsWithCurrManager - Tahun bersama manajer saat ini

Terdiri dari 35 kolom dan bisa dibilang cukup banyak sehingga perlu analisis korelasi.

### Tipe data untuk setiap kolom
"""

df.info()

for col in df.columns:
    unique_count = df[col].nunique()
    print(f"Kolom '{col}' memiliki {unique_count} nilai unik.")

columns_to_check = [
    'BusinessTravel',
    'Department',
    'EducationField',
    'Gender',
    'JobRole',
    'MaritalStatus',
    'Over18',
    'OverTime'
]

for col in columns_to_check:
    unique_values = df[col].unique()
    print(f"Nilai unik di kolom '{col}': {unique_values}")
    print("-" * 30)

"""Untuk data kategorikal bertipe object akan diubah menjadi angka akan disesuaikan dengan jenis datanya.

Untuk kolom 'Attrition' akan diperiksa nilai uniknya. Jika hanya 0 dan 1 setelah menangani NaN, ubah ke int64.

Kolom int64 (ordinal) akan dipertimbangkan tipe datanya.

### Identifikasi nilai yang hilang (missing values)
"""

df.isnull().sum()

"""Terdapat missing value pada kolom 'Attrition' sejumlah 412 data. Akan ditangani di Data Preprocessing.

### Cek data duplikat
"""

df.duplicated().sum()

"""### Distribusi nilai untuk setiap kolom"""

df.describe()

# Pilih hanya kolom numerik
numerical_cols = df.select_dtypes(include=np.number).columns.tolist()
num_cols = len(numerical_cols)
ncols = min(num_cols, 4)
nrows = (num_cols + ncols - 1) // ncols

# Figure dan Axes
fig, axes = plt.subplots(nrows=nrows, ncols=ncols, figsize=(15, 4 * nrows))

axes = axes.flatten()

for i, col in enumerate(numerical_cols):
    ax = axes[i]
    sns.histplot(df[col], kde=True, ax=ax)
    ax.set_title(f'{col} (Skew: {df[col].skew():.2f})', fontsize=10)
    ax.tick_params(axis='both', labelsize=8)

if num_cols < len(axes):
    for j in range(num_cols, len(axes)):
        fig.delaxes(axes[j])

plt.tight_layout()
plt.show()

"""Insight:

- Skewness Tinggi: Beberapa kolom menunjukkan skewness yang cukup tinggi (nilai absolut skewness jauh dari 0). Contohnya :

MonthlyIncome : Right-skewed, artinya sebagian besar karyawan memiliki gaji yang lebih rendah, dengan beberapa karyawan bergaji tinggi

YearsAtCompany : Right-skewed, banyak karyawan yang bekerja sebentar, dengan beberapa yang bekerja sangat lama.

TotalWorkingYears : Right-skewed, pola serupa dengan YearsAtCompany.


- Distribusi Tidak Normal: Banyak kolom tidak mengikuti distribusi normal (berbentuk lonceng). Ini bisa menjadi pertimbangan jika ingin menggunakan model statistik atau machine learning yang mengasumsikan normalitas.

- Potensi Outlier: Distribusi yang sangat skewed seringkali mengindikasikan adanya potensi outlier di ekor yang panjang.

- Distribusi Diskret: Beberapa kolom (seperti kolom dengan skala rating 1-4 atau jumlah tahun) memiliki distribusi diskret, yang memang sesuai dengan sifat datanya.

### Identifikasi outliers
"""

# Dapatkan semua kolom numerik
numerical_cols = df.select_dtypes(include=np.number).columns.tolist()

# Buat box plot untuk setiap kolom numerik
plt.figure(figsize=(20, 15))
for i, col in enumerate(numerical_cols, 1):
    plt.subplot(5, 6, i)
    sns.boxplot(y=df[col])
    plt.title(col, fontsize=10)
    plt.tight_layout()

plt.show()

"""Insight :
- Potensi Outlier: Banyak kolom terlihat memiliki titik-titik di luar whisker, yang mengindikasikan adanya potensi outlier. Contohnya pada kolom seperti MonthlyIncome, NumCompaniesWorked, TotalWorkingYears, YearsAtCompany, YearsInCurrentRole, YearsSinceLastPromotion, dan YearsWithCurrManager.
- Penanganan Outlier perlu mempertimbangkan apakah akan menghapus, mentransformasi, atau membiarkannya. Hal ini tergantung pada kepentingan data dan model yang akan digunakan untuk mencapai tujuan.

### Hubungan antar kolom
"""

# Pilih hanya kolom numerik
numerical_cols = df.select_dtypes(include=np.number)

# Hitung matriks korelasi
correlation_matrix = numerical_cols.corr()

# Buat heatmap korelasi
plt.figure(figsize=(16, 14))  # Ukuran figure disesuaikan agar lebih luas
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f", linewidths=.5)
plt.title('Heatmap Korelasi antar Semua Kolom Numerik', fontsize=16)
plt.xticks(fontsize=10)
plt.yticks(fontsize=10)
plt.tight_layout()
plt.show()

# Pilih hanya kolom numerik (penting untuk kovariansi)
numerical_cols = df.select_dtypes(include=np.number)

# Hitung matriks kovariansi
covariance_matrix = numerical_cols.cov()

# Tampilkan matriks kovariansi
print("Matriks Kovariansi:\n", covariance_matrix)

"""Insight Kovariansi dengan Kolom 'Attrition':

BISA DIHILANGKAN
- EmployeeId: Kovariansi -2.87. Nilai negatif kecil menunjukkan hubungan terbalik yang sangat lemah. ID karyawan kemungkinan tidak relevan dengan attrition.
- DailyRate: Kovariansi -7.97. Nilai negatif kecil menunjukkan hubungan terbalik yang sangat lemah. Gaji harian mungkin tidak menjadi faktor utama attrition secara linear.
- DistanceFromHome: Kovariansi 0.24. Nilai positif sangat kecil menunjukkan hubungan positif yang sangat lemah. Jarak dari rumah mungkin bukan faktor linear yang kuat.
- Education: Kovariansi -0.01. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Tingkat pendidikan mungkin bukan faktor linear yang kuat.
- HourlyRate: Kovariansi -0.13. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Gaji per jam mungkin bukan faktor utama attrition secara linear.
- MonthlyRate: Kovariansi 61.60. Nilai positif kecil menunjukkan hubungan positif yang lemah. Tarif bulanan mungkin bukan faktor utama attrition.
- NumCompaniesWorked: Kovariansi 0.04. Nilai positif sangat kecil menunjukkan hubungan positif yang sangat lemah. Jumlah perusahaan tempat bekerja sebelumnya mungkin bukan faktor linear yang kuat.
- PercentSalaryHike: Kovariansi 0.01. Nilai positif sangat kecil menunjukkan hubungan positif yang sangat lemah. Persentase kenaikan gaji tahun lalu mungkin bukan faktor linear yang kuat.
- PerformanceRating: Kovariansi 0.001. Nilai positif sangat kecil menunjukkan hubungan positif yang sangat lemah. Penilaian kinerja mungkin bukan faktor linear yang kuat.
- RelationshipSatisfaction: Kovariansi -0.02. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Kepuasan hubungan kerja mungkin bukan faktor linear yang kuat.
- TrainingTimesLastYear: Kovariansi -0.02. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Jumlah pelatihan yang diikuti tahun lalu mungkin bukan faktor linear yang kuat.
- WorkLifeBalance: Kovariansi -0.02. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Keseimbangan kerja-hidup mungkin bukan faktor linear yang kuat.
- YearsSinceLastPromotion: Kovariansi -0.04. Nilai negatif sangat kecil menunjukkan hubungan terbalik yang sangat lemah. Tahun sejak promosi terakhir mungkin bukan faktor linear yang kuat.
- EmployeeCount HourlyRate tidak terdapat nilai (0).

DIPERTIMBANGKAN
- Age: Kovariansi -0.61. Nilai negatif kecil menunjukkan bahwa karyawan yang lebih tua sedikit cenderung mengalami attrition yang lebih rendah.
- EnvironmentSatisfaction: Kovariansi -0.05. Nilai negatif kecil menunjukkan bahwa kepuasan lingkungan yang lebih tinggi sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- JobInvolvement: Kovariansi -0.04. Nilai negatif sangat kecil menunjukkan bahwa keterlibatan kerja yang lebih tinggi sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- JobLevel: Kovariansi -0.07. Nilai negatif kecil menunjukkan bahwa tingkat pekerjaan yang lebih tinggi sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- JobSatisfaction: Kovariansi -0.04. Nilai negatif sangat kecil menunjukkan bahwa kepuasan kerja yang lebih tinggi sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- MonthlyIncome: Kovariansi -296.87. Nilai negatif yang lebih besar (dibandingkan yang lain) menunjukkan bahwa gaji bulanan yang lebih tinggi cenderung berkorelasi dengan attrition yang lebih rendah. Ini adalah salah satu faktor numerik yang lebih kuat berdasarkan kovariansi.
- StockOptionLevel: Kovariansi -0.05. Nilai negatif kecil menunjukkan bahwa tingkat opsi saham yang lebih tinggi sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- TotalWorkingYears: Kovariansi -0.53. Nilai negatif kecil menunjukkan bahwa total tahun bekerja yang lebih banyak sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- YearsAtCompany: Kovariansi -0.32. Nilai negatif kecil menunjukkan bahwa tahun bekerja di perusahaan saat ini yang lebih banyak sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- YearsInCurrentRole: Kovariansi -0.22. Nilai negatif kecil menunjukkan bahwa tahun dalam peran saat ini yang lebih banyak sedikit cenderung berkorelasi dengan attrition yang lebih rendah.
- YearsWithCurrManager: Kovariansi -0.21. Nilai negatif kecil menunjukkan bahwa tahun bersama manajer saat ini yang lebih banyak sedikit cenderung berkorelasi dengan attrition yang lebih rendah.

Adapun akan dicek kembali dari hasil pre processing.

## Data Preparation / Preprocessing

### Encoding Data Kategorikal
"""

# Mapping dictionary untuk setiap kolom
business_travel_mapping = {'Travel_Frequently': 1, 'Travel_Rarely': 2, 'Non-Travel': 3}
department_mapping = {'Human Resources': 1, 'Research & Development': 2, 'Sales': 3}
education_field_mapping = {'Other': 1, 'Medical': 2, 'Life Sciences': 3, 'Marketing': 4, 'Technical Degree': 5, 'Human Resources': 6}
gender_mapping = {'Male': 1, 'Female': 2}
job_role_mapping = {'Human Resources': 1, 'Healthcare Representative': 2, 'Research Scientist': 3, 'Sales Executive': 4, 'Manager': 5, 'Laboratory Technician': 6, 'Research Director': 7, 'Manufacturing Director': 8, 'Sales Representative': 9}
marital_status_mapping = {'Married': 1, 'Single': 2, 'Divorced': 3}
over18_mapping = {'Y': 1}
overtime_mapping = {'Yes': 1, 'No': 0}

# Terapkan mapping ke kolom asli, sehingga nilai aslinya tergantikan
df['BusinessTravel'] = df['BusinessTravel'].map(business_travel_mapping)
df['Department'] = df['Department'].map(department_mapping)
df['EducationField'] = df['EducationField'].map(education_field_mapping)
df['Gender'] = df['Gender'].map(gender_mapping)
df['JobRole'] = df['JobRole'].map(job_role_mapping)
df['MaritalStatus'] = df['MaritalStatus'].map(marital_status_mapping)
df['Over18'] = df['Over18'].map(over18_mapping)
df['OverTime'] = df['OverTime'].map(overtime_mapping)

# Tampilkan beberapa baris pertama DataFrame yang telah diubah
print("Beberapa baris pertama DataFrame setelah encoding (kolom asli diganti):")
print(df[[
    'BusinessTravel',
    'Department',
    'EducationField',
    'Gender',
    'JobRole',
    'MaritalStatus',
    'Over18',
    'OverTime'
]].head())

# Tampilkan informasi DataFrame untuk memverifikasi tipe data
print("\nInformasi DataFrame setelah encoding:")
print(df.info())

df.head()

"""### Menangani Missing Value"""

# Hitung modus kolom 'Attrition'
modus_attrition = df['Attrition'].mode()[0]

# Isi missing value dengan modus
df['Attrition'].fillna(modus_attrition, inplace=True)

df.isnull().sum()

"""### Ubah Tipe Data"""

df.info()

df['Attrition'] = df['Attrition'].astype(int)
df.info()

"""Berdasarkan analisis hasilnya, ada beberapa kolom terbagi menjadi data ordinal dan nominal.

Adapun data ordinal adalah sebagai berikut ['Education', 'EnvironmentSatisfaction','JobInvolvement', 'JobLevel','JobSatisfaction', 'PerformanceRating','RelationshipSatisfaction', 'StockOptionLevel','WorkLifeBalance'].

Adapun data nominal adalah sebagai berikut ['Attrition', 'BusinessTravel','Department', 'EducationField','Gender', 'JobRole','MaritalStatus', 'Over18','OverTime'].
"""

# Daftar kolom ordinal
ordinal_cols = ['Education', 'EnvironmentSatisfaction', 'JobInvolvement', 'JobLevel',
                'JobSatisfaction', 'PerformanceRating', 'RelationshipSatisfaction',
                'StockOptionLevel', 'WorkLifeBalance']

# Daftar kolom nominal
nominal_cols = ['Attrition', 'BusinessTravel', 'Department', 'EducationField',
                'Gender', 'JobRole', 'MaritalStatus', 'Over18', 'OverTime']

# Gabungkan kedua daftar kolom
cols_to_category = ordinal_cols + nominal_cols

def ubah_ke_category(df, cols_to_category):
    for col in cols_to_category:
        if col in df.columns:
            df[col] = df[col].astype('category')
        else:
            print(f"Kolom '{col}' tidak ditemukan dalam DataFrame.")
    return df

df = ubah_ke_category(df, cols_to_category)
print(df.dtypes)

df.info()

"""### Analisis Univariate

#### EDA - Analisis Nilai Numerik
"""

numerical_cols = [
    'Age',
    'DailyRate',
    'DistanceFromHome',
    'EmployeeCount',
    'HourlyRate',
    'MonthlyIncome',
    'MonthlyRate',
    'NumCompaniesWorked',
    'PercentSalaryHike',
    'StandardHours',
    'TotalWorkingYears',
    'TrainingTimesLastYear',
    'YearsAtCompany',
    'YearsInCurrentRole',
    'YearsSinceLastPromotion',
    'YearsWithCurrManager'
]

# Contoh analisis: Rata-rata (mean) untuk setiap kolom numerik
print("--- Rata-rata (Mean) ---")
for col in numerical_cols:
    print(f"{col}: {df[col].mean()}")

# Contoh analisis: Standar deviasi (std) untuk setiap kolom numerik
print("\n--- Standar Deviasi (Standard Deviation) ---")
for col in numerical_cols:
    print(f"{col}: {df[col].std()}")

# Contoh analisis: Statistik deskriptif lengkap untuk SEMUA kolom numerik
print("\n--- Statistik Deskriptif untuk Semua Kolom Numerik ---")
df[numerical_cols].describe()

def plot_numerical_histograms(df, numerical_cols, cols_per_row=4):
    n_cols = len(numerical_cols)
    n_rows = int(np.ceil(n_cols / cols_per_row))

    fig, axes = plt.subplots(nrows=n_rows, ncols=cols_per_row, figsize=(cols_per_row * 6, n_rows * 4))

    for i, col in enumerate(numerical_cols):
        row_idx = i // cols_per_row
        col_idx = i % cols_per_row

        if n_rows > 1:
            ax = axes[row_idx, col_idx]
        else:
            ax = axes[col_idx]

        sns.histplot(df[col], kde=True, ax=ax)
        ax.set_title(f'Distribusi {col}')
        ax.set_xlabel(col)
        ax.set_ylabel('Frekuensi')

    # Hapus subplot kosong jika ada
    if n_cols < n_rows * cols_per_row:
        for j in range(n_cols, n_rows * cols_per_row):
            if n_rows > 1:
                fig.delaxes(axes.flatten()[j])
            else:
                fig.delaxes(axes[j])

    plt.tight_layout()
    plt.show()

plot_numerical_histograms(df, numerical_cols)

def plot_numerical_boxplots(df, numerical_cols, cols_per_row=4):
    n_cols = len(numerical_cols)
    n_rows = int(np.ceil(n_cols / cols_per_row))

    fig, axes = plt.subplots(nrows=n_rows, ncols=cols_per_row, figsize=(cols_per_row * 6, n_rows * 4))

    for i, col in enumerate(numerical_cols):
        row_idx = i // cols_per_row
        col_idx = i % cols_per_row

        if n_rows > 1:
            ax = axes[row_idx, col_idx]
        else:
            ax = axes[col_idx]

        sns.boxplot(y=df[col], ax=ax)
        ax.set_title(f'Boxplot {col}')
        ax.set_ylabel(col)

        # Kosongkan label x-axis karena tidak relevan untuk boxplot tunggal
        ax.set_xlabel('')
        ax.set_xticks([])

    # Hapus subplot kosong jika ada
    if n_cols < n_rows * cols_per_row:
        for j in range(n_cols, n_rows * cols_per_row):
            if n_rows > 1:
                fig.delaxes(axes.flatten()[j])
            else:
                fig.delaxes(axes[j])

    plt.tight_layout()
    plt.show()

plot_numerical_boxplots(df, numerical_cols)

"""#### EDA - Analisis Nilai Kategorikal"""

categorical_cols = [
    'Attrition',
    'BusinessTravel',
    'Department',
    'Education',
    'EducationField',
    'EnvironmentSatisfaction',
    'Gender',
    'JobInvolvement',
    'JobLevel',
    'JobRole',
    'JobSatisfaction',
    'MaritalStatus',
    'Over18',
    'OverTime',
    'PerformanceRating',
    'RelationshipSatisfaction',
    'StockOptionLevel',
    'WorkLifeBalance'
]

def plot_categorical_bar_charts(df, categorical_cols, cols_per_row=4):
    n_cols = len(categorical_cols)
    n_rows = int(np.ceil(n_cols / cols_per_row))

    fig, axes = plt.subplots(nrows=n_rows, ncols=cols_per_row, figsize=(cols_per_row * 6, n_rows * 4))

    for i, col in enumerate(categorical_cols):
        row_idx = i // cols_per_row
        col_idx = i % cols_per_row

        if n_rows > 1:
            ax = axes[row_idx, col_idx]
        else:
            ax = axes[col_idx]

        # Menghitung frekuensi setiap kategori
        counts = df[col].value_counts()
        sns.barplot(x=counts.index, y=counts.values, ax=ax)

        ax.set_title(f'Distribusi {col}')
        ax.set_xlabel(col)
        ax.set_ylabel('Frekuensi')
        ax.tick_params(axis='x', rotation=45)  # Rotasi label x jika terlalu panjang

    # Hapus subplot kosong jika ada
    if n_cols < n_rows * cols_per_row:
        for j in range(n_cols, n_rows * cols_per_row):
            if n_rows > 1:
                fig.delaxes(axes.flatten()[j])
            else:
                fig.delaxes(axes[j])

    plt.tight_layout()
    plt.show()

# Panggil fungsi untuk menampilkan diagram batang dalam grid
plot_categorical_bar_charts(df, categorical_cols)

def plot_categorical_pie_charts(df, categorical_cols, cols_per_row=4):
    n_cols = len(categorical_cols)
    n_rows = int(np.ceil(n_cols / cols_per_row))

    fig, axes = plt.subplots(nrows=n_rows, ncols=cols_per_row, figsize=(cols_per_row * 6, n_rows * 4))

    for i, col in enumerate(categorical_cols):
        row_idx = i // cols_per_row
        col_idx = i % cols_per_row

        if n_rows > 1:
            ax = axes[row_idx, col_idx]
        else:
            ax = axes[col_idx]

        # Menghitung frekuensi setiap kategori
        counts = df[col].value_counts()
        labels = counts.index
        sizes = counts.values

        ax.pie(sizes, labels=labels, autopct='%1.1f%%', startangle=90)
        ax.set_title(f'Distribusi {col}')

    # Hapus subplot kosong jika ada
    if n_cols < n_rows * cols_per_row:
        for j in range(n_cols, n_rows * cols_per_row):
            if n_rows > 1:
                fig.delaxes(axes.flatten()[j])
            else:
                fig.delaxes(axes[j])

    plt.tight_layout()
    plt.show()

# Panggil fungsi untuk menampilkan diagram pie dalam grid
plot_categorical_pie_charts(df, categorical_cols)

import pandas as pd
from scipy.stats import chi2_contingency
from itertools import combinations  # Untuk membuat pasangan kolom

def chi_square_test_all_categorical(df, categorical_cols):
    for col1, col2 in combinations(categorical_cols, 2):
        if col1 not in df.columns or col2 not in df.columns:
            print(f"Peringatan: Salah satu atau kedua kolom '{col1}' atau '{col2}' tidak ditemukan. Melewati pasangan ini.")
            continue  # Lewati pasangan kolom ini

        print(f"\n--- Uji Chi-Square antara '{col1}' dan '{col2}' ---")
        cross_tab = pd.crosstab(df[col1], df[col2])
        chi2, p, dof, expected = chi2_contingency(cross_tab)

        print("Chi-Square Statistic:", chi2)
        print("P-value:", p)
        print("Degrees of Freedom:", dof)

        alpha = 0.05
        if p < alpha:
            print(f"Kesimpulan: Ada hubungan yang signifikan antara '{col1}' dan '{col2}'.")
        else:
            print(f"Kesimpulan: Tidak ada cukup bukti untuk menyimpulkan adanya hubungan antara '{col1}' dan '{col2}'.")

chi_square_test_all_categorical(df, categorical_cols)

"""### Analisis Bivariate

**KATEGORIKAL VS 'Attration'**

Adapun untuk kolom kategorikal dan 'Attration' sudah dilakukan pada analisis Univariate kategorikal vs kategorikal sehingga sekarang perlu dilakukan penghapusan kolom yang tidak ada hubungan dengan 'Attration'.
"""

kolom_yang_dihapus = [
    'Department',
    'Education',
    'Gender',
    'Over18',
    'PerformanceRating',
    'RelationshipSatisfaction'
]

# Menghapus kolom-kolom tersebut dari DataFrame
df = df.drop(columns=kolom_yang_dihapus, errors='ignore')

df.columns

"""**NUMERIKAL VS 'Attration'**

Akan digunakan uji t-test karena dapat melakukan korelasi untuk data kategorikal biner dengan numerik dengan banyak data numerik.
"""

import pandas as pd
from scipy import stats

def t_test_attrition_numerical(df, numerical_cols, attrition_col='Attrition'):
    if attrition_col not in df.columns:
        print(f"Kolom '{attrition_col}' tidak ditemukan dalam DataFrame.")
        return

    attrition_values = df[attrition_col].unique()
    if len(attrition_values) != 2:
        print(f"Kolom '{attrition_col}' harus memiliki tepat dua kategori untuk t-test. Ditemukan: {attrition_values}")
        return

    group1 = df[df[attrition_col] == attrition_values[0]]
    group2 = df[df[attrition_col] == attrition_values[1]]

    print(f"Melakukan t-test antara '{attrition_col}' ({attrition_values[0]} vs {attrition_values[1]}) dan kolom numerik:\n")

    results = {}
    for col in numerical_cols:
        if col in df.columns:
            t_statistic, p_value = stats.ttest_ind(group1[col], group2[col], nan_policy='omit')
            results[col] = {'t_statistic': t_statistic, 'p_value': p_value}
            alpha = 0.05
            if p_value < alpha:
                significance = "signifikan"
            else:
                significance = "tidak signifikan"
            print(f"- {col}: t = {t_statistic:.3f}, p = {p_value:.3f} (Perbedaan rata-rata {significance})")
        else:
            print(f"- Kolom '{col}' tidak ditemukan dalam DataFrame.")

    return results


results_ttest = t_test_attrition_numerical(df.copy(), numerical_cols)
print(results_ttest)

"""Insight:
- Signifikan: Kolom seperti 'Age', 'DistanceFromHome', 'MonthlyIncome', 'TotalWorkingYears', 'YearsAtCompany', 'YearsInCurrentRole', dan 'YearsWithCurrManager' menunjukkan perbedaan rata-rata yang signifikan antara karyawan yang attrition dan yang tidak. Misalnya, rata-rata usia karyawan yang attrition mungkin berbeda secara signifikan dari rata-rata usia karyawan yang tidak attrition.

- Tidak Signifikan: Kolom seperti 'DailyRate','EmployeeCount', 'HourlyRate', 'MonthlyRate', 'NumCompaniesWorked', 'PercentSalaryHike', 'StandardHours','TrainingTimesLastYear', dan 'YearsSinceLastPromotion' tidak menunjukkan perbedaan rata-rata yang signifikan antara kedua kelompok attrition. Ini berarti rata-rata nilai-nilai pada kolom ini relatif serupa antara karyawan yang keluar dan yang tidak.

- Untuk 'EmployeeCount' dan 'StandardHours' yang p-value dan t-statisticnya 'nan', ini kemungkinan karena kolom-kolom tersebut memiliki varians nol (semua nilainya sama) dalam salah satu atau kedua kelompok, sehingga perhitungan t-test tidak dapat dilakukan dengan baik.
"""

print(df['EmployeeCount'].value_counts())
print(df['StandardHours'].value_counts())

kolom_yang_dihapus1 = [
    'DailyRate',
    'EmployeeCount',
    'HourlyRate',
    'MonthlyRate',
    'NumCompaniesWorked',
    'PercentSalaryHike',
    'StandardHours',
    'TrainingTimesLastYear',
    'YearsSinceLastPromotion'
]

# Menghapus kolom-kolom tersebut dari DataFrame
df = df.drop(columns=kolom_yang_dihapus1, errors='ignore')

df.columns

df.head()

"""Diperoleh dari 34 kolom menjadi 19 kolom yang punya keterkaitan dengan kolom 'Attration'.

## Modeling

### Pemilihan Target dan Fitur
"""

target_var = ['Attrition']
feature_var = [
    'Age',
    'BusinessTravel',
    'DistanceFromHome',
    'EducationField',
    'EnvironmentSatisfaction',
    'JobInvolvement',
    'JobLevel',
    'JobRole',
    'JobSatisfaction',
    'MaritalStatus',
    'MonthlyIncome',
    'OverTime',
    'StockOptionLevel',
    'TotalWorkingYears',
    'WorkLifeBalance',
    'YearsAtCompany',
    'YearsInCurrentRole',
    'YearsWithCurrManager'
]

"""### Ubah data menjadi numerik semua"""

gabungan_var = target_var + feature_var

def convert_to_int(df, gabungan_var):
    for col in gabungan_var:
        if col in df.columns:
            try:
                # Check if the column dtype is 'category' before converting
                if df[col].dtype.name == 'category':
                    df[col] = df[col].cat.codes # Convert category to numerical codes
                df[col] = df[col].astype(int)
            except ValueError:
                print(f"Tidak dapat mengubah kolom '{col}' menjadi int. Kolom '{col}' mungkin berisi data non-numerik setelah penanganan awal.")
        else:
            print(f"Kolom '{col}' tidak ditemukan dalam DataFrame.")

convert_to_int(df, gabungan_var)

print(df.dtypes)

def standardize_data(df, feature_var, target_var='Attrition'):
    X = df[feature_var]
    y = df[target_var]

    # Bagi data menjadi train dan test set
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # Inisialisasi StandardScaler
    scaler = StandardScaler()

    # Fit scaler hanya pada data latih
    X_train_scaled = scaler.fit_transform(X_train)

    # Transformasikan data uji menggunakan scaler yang sama
    X_test_scaled = scaler.transform(X_test)

    # Ubah kembali ke DataFrame (opsional, tergantung kebutuhan Anda)
    X_train_scaled_df = pd.DataFrame(X_train_scaled, columns=X_train.columns, index=X_train.index)
    X_test_scaled_df = pd.DataFrame(X_test_scaled, columns=X_test.columns, index=X_test.index)

    return X_train_scaled_df, X_test_scaled_df, y_train, y_test

X_train_scaled, X_test_scaled, y_train, y_test = standardize_data(df.copy(), feature_var, target_var)

print("Data Latih yang Distandarisasi:")
print(X_train_scaled.head())
print("\nData Uji yang Distandarisasi:")
print(X_test_scaled.head())
print("\nTarget Latih:")
print(y_train.head())
print("\nTarget Uji:")
print(y_test.head())

"""### Penanganan Outlier"""

def plot_numerical_boxplots(df, numerical_cols, cols_per_row=4):
    n_cols = len(numerical_cols)
    n_rows = int(np.ceil(n_cols / cols_per_row))

    fig, axes = plt.subplots(nrows=n_rows, ncols=cols_per_row, figsize=(cols_per_row * 6, n_rows * 4))

    for i, col in enumerate(numerical_cols):
        row_idx = i // cols_per_row
        col_idx = i % cols_per_row

        if n_rows > 1:
            ax = axes[row_idx, col_idx]
        else:
            ax = axes[col_idx]

        sns.boxplot(y=df[col], ax=ax)
        ax.set_title(f'Boxplot {col}')
        ax.set_ylabel(col)
        ax.set_xlabel('')
        ax.set_xticks([])

    if n_cols < n_rows * cols_per_row:
        for j in range(n_cols, n_rows * cols_per_row):
            if n_rows > 1:
                fig.delaxes(axes.flatten()[j])
            else:
                fig.delaxes(axes[j])

    plt.tight_layout()
    plt.show()

plot_numerical_boxplots(df.copy(), gabungan_var)

"""'EducationField' karena kategorikal jadi jangan diubah nilainya.

'MonthlyIncome' karena ini merupakan gaji sehingga wajar jika ada yang tinggi diantara yang lain.

'StockOptionLevel' karena kategorikal jadi jangan diubah nilainya.

'TotalWorkingYears' karena ini merupakan total tahun bekerja sehingga wajar jika ada yang nilainya kecil dan besar diantara yang lain.

'YearsAtCompany' karena ini merupakan tahun bekerja sehingga wajar jika ada yang nilainya kecil dan besar diantara yang lain.

'YearsInCurrentRole' karena ini merupakan tahun dalam peran saat ini sehingga wajar jika ada yang nilainya kecil dan besar diantara yang lain.

'YearsWithCurrManager' karena ini merupakan tahun bersama manajer saat ini sehingga wajar jika ada yang nilainya kecil dan besar diantara yang lain.

### Pemilihan Model
"""

# Inisialisasi model-model yang akan dicoba
models = {
    'Logistic Regression': LogisticRegression(random_state=42),
    'Random Forest': RandomForestClassifier(random_state=42),
    'XGBoost': xgb.XGBClassifier(random_state=42)
}

results = {}

# Latih dan evaluasi setiap model
for name, model in models.items():
    # Latih model
    model.fit(X_train_scaled, y_train)

    # Lakukan prediksi pada data uji
    y_pred = model.predict(X_test_scaled)

    # Hitung akurasi
    accuracy = accuracy_score(y_test, y_pred)
    results[name] = accuracy

# Buat DataFrame untuk menampilkan hasil dalam bentuk tabel
results_df = pd.DataFrame.from_dict(results, orient='index', columns=['Accuracy'])

# Cetak tabel hasil
print("\nPerbandingan Akurasi Model:")
print(results_df)

def tune_and_evaluate_random_forest(X_train, y_train, X_test, y_test):
    # Parameter yang akan di-tune
    param_grid = {
        'n_estimators': [50, 100, 200],
        'max_depth': [5, 10, 15],
        'min_samples_split': [2, 5, 10],
        'min_samples_leaf': [1, 2, 4],
        'criterion': ['gini', 'entropy']
    }

    # Inisialisasi GridSearchCV
    grid_search = GridSearchCV(estimator=RandomForestClassifier(random_state=42),
                               param_grid=param_grid,
                               cv=3,
                               scoring='accuracy',
                               verbose=1,
                               n_jobs=-1)

    # Lakukan Grid Search pada data latih
    grid_search.fit(X_train, y_train)

    # Parameter terbaik
    best_params = grid_search.best_params_
    print("Parameter Terbaik:", best_params)

    # Model terbaik
    best_model = grid_search.best_estimator_

    # Lakukan prediksi pada data uji menggunakan model terbaik
    y_pred_best = best_model.predict(X_test)

    # Evaluasi model terbaik
    classification_rep = classification_report(y_test, y_pred_best, target_names=['No Attrition', 'Attrition'])
    confusion_mat = confusion_matrix(y_test, y_pred_best)
    accuracy = accuracy_score(y_test, y_pred_best)

    print("\nClassification Report Terbaik:")
    print(classification_rep)

    print("\nConfusion Matrix Terbaik:")
    print(confusion_mat)

    print(f"\nAkurasi Model Terbaik: {accuracy:.4f}")

    return best_model, best_params, classification_rep, confusion_mat, accuracy


from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# Panggil fungsi tuning dan evaluasi
best_model, best_params, classification_rep, confusion_mat, accuracy = tune_and_evaluate_random_forest(
    X_train_scaled, y_train, X_test_scaled, y_test
)

"""## Evaluation"""

# Prediksi pada data uji yang telah diskalakan
y_pred = best_model.predict(X_test_scaled)
y_pred_proba = best_model.predict_proba(X_test_scaled)[:, 1]  # Probabilitas untuk kelas positif ('Attrition')

# Evaluasi
print("Classification Report:\n", classification_report(y_test, y_pred, target_names=['No Attrition', 'Attrition']))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred))
print("Accuracy:", accuracy_score(y_test, y_pred))

# ROC AUC
auc = roc_auc_score(y_test, y_pred_proba)
print("AUC:", auc)

# Kurva ROC
fpr, tpr, thresholds = roc_curve(y_test, y_pred_proba)
plt.plot(fpr, tpr, label=f'AUC = {auc:.2f}')
plt.plot([0, 1], [0, 1], linestyle='--', color='r')  # Garis acak
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.title('ROC Curve')
plt.legend()
plt.show()

"""Insight:

Nilai AUC sebesar 0.77 menunjukkan bahwa model  memiliki kemampuan yang cukup baik dalam membedakan antara karyawan yang akan mengalami attrition dan yang tidak. Ada peluang 77% bahwa model akan memberikan peringkat yang lebih tinggi pada karyawan yang benar-benar mengalami attrition dibandingkan dengan karyawan yang tidak, secara acak.

# Persiapan Data Untuk Dashboard
"""

df.head()

df['Attrition'] = df['Attrition'].map({0:'No', 1:'Yes'})

df['BusinessTravel'] = df['BusinessTravel'].map({0:'Travel_Frequently', 1:'Travel_Rarely', 2:'Non-Travel'})

df['EducationField'] = df['EducationField'].map({0:'Other', 1:'Medical', 2:'Life Sciences', 3:'Marketing', 4:'Technical Degree', 5:'Human Resources'})

df['EnvironmentSatisfaction'] = df['EnvironmentSatisfaction'].map({0:'Low', 1:'Medium', 2:'High', 3:'Very High'})

df['JobInvolvement'] = df['JobInvolvement'].map({0:'Low', 1:'Medium', 2:'High', 3:'Very High'})

df['JobRole'] = df['JobRole'].map({0:'Human Resources', 1:'Healthcare Representative', 2:'Research Scientist', 3:'Sales Executive', 4:'Manager', 5:'Laboratory Technician', 6:'Research Director', 7:'Manufacturing Director', 8:'Sales Representative'})

df['JobSatisfaction'] = df['JobSatisfaction'].map({0:'Low', 1:'Medium', 2:'High', 3:'Very High'})

df['MaritalStatus'] = df['MaritalStatus'].map({0:'Married', 1:'Single', 2:'Divorced'})

df['OverTime'] = df['OverTime'].map({0:'No', 1:'Yes'})

df['WorkLifeBalance'] = df['WorkLifeBalance'].map({0:'Low', 1:'Good', 2:'Excellent', 3:'Outstanding'})

df.head()

nama_file_csv = 'hasil_analisis.csv'
df.to_csv(nama_file_csv, index=False)
print(f"DataFrame berhasil disimpan ke '{nama_file_csv}'")

! pip freeze > requirements.txt
